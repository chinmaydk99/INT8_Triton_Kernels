# -*- coding: utf-8 -*-
"""int8_fused_dequant_matmul_rowwise

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1igZPi-KXF-gpLsX-CuiypbNN8157GHSs
"""

import torch
import triton
import triton.language as tl

"""Dequantisation:

![image.png](data:image/png;base64,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)
"""

@triton.jit
def fused_dequant_matmul_rowwise_kernel(
    x_ptr,
    w_ptr,
    y_ptr,
    bias,
    scale_x_ptr,  # Scaling factor per row of x
    scale_w_ptr,  # Scaling factor per column of y
    stride_xm, stride_xk,
    stride_wk, stride_wn,
    stride_ym, stride_yn,
    has_bias: tl.constexpr,
    M, N, K,
    divfactor,  # 1/128*128 for INT8
    BLOCK_SIZE_M: tl.constexpr,
    BLOCK_SIZE_N: tl.constexpr,
    BLOCK_SIZE_K: tl.constexpr,
    GROUP_SIZE_M: tl.constexpr,
    SPLIT_K: tl.constexpr,
    EVEN_K: tl.constexpr
):

    pid_mn = tl.program_id(0)
    pid_k = tl.program_id(1)

    num_blocks_m = tl.cdiv(M, BLOCK_SIZE_M)
    num_blocks_n = tl.cdiv(N, BLOCK_SIZE_N)

    num_blocks_in_group = GROUP_SIZE_M * num_blocks_n

    group_id = pid_mn // num_blocks_in_group
    group_size_m = min(GROUP_SIZE_M, num_blocks_m - group_id * GROUP_SIZE_M)

    pid_m = group_id * GROUP_SIZE_M + pid_mn % group_size_m  # Rows go from 0 - group_size_m
    pid_n = (pid_mn % num_blocks_in_group) // group_size_m  # Each offset holds group_size_m elements. Cols go from 0 - num_blocks_in_group

    offsets_xm = pid_m * BLOCK_SIZE_M + tl.arange(0, BLOCK_SIZE_M)
    offsets_wn = pid_n * BLOCK_SIZE_N + tl.arange(0, BLOCK_SIZE_N)

    offsets_xm = tl.max_contiguous(tl.multiple_of(offsets_xm % M, BLOCK_SIZE_M), BLOCK_SIZE_M)
    offsets_wn = tl.max_contiguous(tl.multiple_of(offsets_wn % N, BLOCK_SIZE_N), BLOCK_SIZE_N)

    offsets_k = pid_k * BLOCK_SIZE_K + tl.arange(0, BLOCK_SIZE_K)

    # Compute pointers into x and w
    x = x_ptr + (offsets_xm[:, None] * stride_xm + offsets_k[None, :] * stride_xk)
    w = w_ptr + (offsets_k[:, None] * stride_wk + offsets_wn[None, :] * stride_wn)

    x_scale_factor = tl.load(scale_x_ptr + offsets_xm)[:, None]  # Scaling factor for x per row
    w_scale_factor = tl.load(scale_w_ptr + offsets_wn)[None, :]  # Scaling factor for w per column

    acc = tl.zeros((BLOCK_SIZE_M, BLOCK_SIZE_N), dtype=tl.int32)

    for k in range(tl.cdiv(K, BLOCK_SIZE_K * SPLIT_K)):
        if EVEN_K:
            x_data = tl.load(x)
            w_data = tl.load(w)

        else:
            # This is for the last block
            k_remaining = K - k * BLOCK_SIZE_K * SPLIT_K
            x_data = tl.load(x, mask=offsets_k[None, :] < k_remaining, other=0.0)
            w_data = tl.load(w, mask=offsets_k[:, None] < k_remaining, other=0.0)

        acc += tl.dot(x_data, w_data)

        # Moving pointers to next K-tile
        x += BLOCK_SIZE_K * SPLIT_K * stride_xk
        w += BLOCK_SIZE_K * SPLIT_K * stride_wk

    # Dequantization
    acc = w_scale_factor * (x_scale_factor * (acc * divfactor))
    acc = acc.to(y_ptr.dtype.element_ty)  # Cast to whichever format the output expects

    if has_bias:
        bias_val = tl.load(bias + offsets_wn).to(y_ptr.dtype.element_ty)
        acc = acc + bias_val[None, :]  # Add bias value to each row

    # Compute output pointer
    y_ptr = y_ptr + offsets_xm[:, None] * stride_ym + offsets_wn[None, :] * stride_yn
    mask = (offsets_xm[:, None] < M) & (offsets_wn[None, :] < N)

    if SPLIT_K == 1:
        tl.store(y_ptr, acc, mask=mask)
    else:
      # Need to aggregate across blocks
        tl.atomic_add(y_ptr, acc, mask=mask

def int8_fused_dequant_matmul_rowwise(x, w, scale_x, scale_w, bias = None):
    div_factor = 1 / (127.0 * 127.0)
    has_bias = 1 if bias is not None else 0
    device = x.device

    if x.stride(0) > 1 and x.stride(1) > 1:
            x = x.contiguous()
    if w.stride(0) > 1 and w.stride(1) > 1:
        w = w.contiguous()

    assert x.shape[1] == w.shape[0]
    M, K = x.shape
    _, N = w.shape

    y = torch.empty((M, N), dtype=torch.float16, device=device)

    grid = lambda meta:(triton.cdiv(M, meta["BLOCK_SIZE_M"]) * triton.cdiv(N, meta["BLOCK_SIZE_N"], meta["SPLIT_K"]))

    fused_dequant_matmul_rowwise_kernel[grid](
        x, w, y, bias, scale_x, scale_w,
        x.stride(0), x.stride(1),
        w.stride(0), w.stride(1),
        y.stride(0), y.stride(1),
        has_bias,
        M, N, K,
        div_factor,
        GROUP_SIZE_M = 8
    )
    return y